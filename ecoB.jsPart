

                    "colors":{"target1":col1, "trunk":col2, "branches":null}
                };
                break;
            default:
            	console.log(
            		"error 6: that's not a category! (at least not yet) you gave me: " +
            		category
            	);
            //bird, microbe, tree, monster, crystal
        }
    },

    myColor: function(mean, variance) {
        var hVar;
        var sVar;
        var vVar;
        if (variance == null) {
            hVar = 0.01;
            sVar = 0.1;
            vVar = 0.1;
        } else if (variance < 1) {
            hVar = 0.1 * variance;
            sVar = 1 * variance;
            vVar = 1 * variance;
        } else {
            hVar = 0.1 * variance;
            sVar = 0.1 * variance;
            vVar = 0.1 * variance;
        }
        var c = Raphael.color(mean);
        var hue = Ecosystem.uniformAroundMean(c.h, hVar);
        var saturation = Ecosystem.uniformAroundMean(c.s, sVar);
        var value = Ecosystem.uniformAroundMean(c.v, vVar);
        var newColor = Raphael.hsb2rgb(hue, saturation, value);
        return newColor.hex;
    },

    appropriateSample: function(propertyname) {
    	var type = propertyname.slice(0,propertyname.length-1);
    	switch(type) {
    		case "tar":
    			return Ecosystem.randBoul();
    			break;
    		case "col":
    			return Ecosystem.randCol();
    			break;
    		case "prop":
    			return Ecosystem.randProp();
    			break;
    		default:
    			console.log("error 94: that's not actually a property that i know how to deal with. you should give me 'tar', 'col', or 'prop', but you gave me " + propertyname + ".");
    	}
    },

    /* Possible propParams:
         * tar1/tar2: probability of having that property
         * col1/col2/col3/col4/col5: mean color and var from [0,?]
         * prop1/prop2: mean and var from [0,1]
    */
    Genus: function(category, propsAndParams) {
        this.category = category;
        this.propsAndParams = (propsAndParams == null) ? {} : propsAndParams;

        this.update = function() {
	        var varprops = ["col1", "col2", "col3", "col4", "col5",
	                        "prop1", "prop2"];

	        //can specify an overall variance
	        /*if there is an overall variance, any variances that the user doesn't
	          specify will be set to the overall variance and any means that the
	          user doesn't specify will be randomly sampled for the category */
	        if (this.propsAndParams["var"] != null) {
                var variance = this.propsAndParams["var"];
	        	for (var i=0; i<varprops.length; i++) {
	        		var p = varprops[i];

	        		/*make a mean/var object for each variable property that
	        		doesn't already have one*/
	        		if (this.propsAndParams[p] == null) {
	        			this.propsAndParams[p] = {};
	        		}

	                //if there's no variance, fill it in with overall var
	        		if (this.propsAndParams[p]["var"] == null) {
	        			this.propsAndParams[p]["var"] = variance;
	        		}

	        		//if there's no mean, make one
	        		if (this.propsAndParams[p]["mean"] == null) {
	        			this.propsAndParams[p]["mean"] = Ecosystem.appropriateSample(p);
	        	    }
	        	}
	        } else {
	        /*if no overall variance is specified, still go through and fill in
	          means wherever you have a variance and no mean*/
	        	for (var i=0; i<varprops.length; i++) {
	        		var p = varprops[i];
	        		if (this.propsAndParams[p] != null) {
		        		if (this.propsAndParams[p]["var"] != null &&
		        			this.propsAndParams[p]["mean"] == null) {
		        			this.propsAndParams[p]["mean"] = Ecosystem.appropriateSample(p);
		        		} else if (this.propsAndParams[p]["mean"] != null &&
                            this.propsAndParams[p]["var"] == null) {
                            this.propsAndParams[p]["var"] = 0.2;
                        }
		        	}
	        	}
	        }
	    }

	    this.update();

	    this.backwardsCompatibility = function(meanVars, props) {
	    	for (var i=0; i<meanVars.length; i++) {
        		var pair = meanVars[i];
        		var mean = (props[pair[0]] == null) ? null : props[pair[0]];
        		var variance = (props[pair[1]] == null) ? null : props[pair[1]];
        		var name = pair[2];
        		if (mean != null && variance != null) {
        			this.propsAndParams[name] = {"mean":mean, "var":variance};
        		} else if (mean != null) {
        			this.propsAndParams[name] = {"mean":mean};
        		} else if (variance != null) {
        			this.propsAndParams[name] = {"var":variance};
        		}
	    	}
	    	if (props["var"] != null) {
	    		this.propsAndParams["var"] = props["var"];
	    	}
	    }

        this.draw = function(paperlabel, tokenProperties, scaleFactor) {
        	var tokenProperties = (tokenProperties == null) ? {} : tokenProperties;

            //get user-specified properties of the token or sample from category means
            var specifiedProps = Object.keys(this.propsAndParams);
            rm(specifiedProps, "var");
            for (var i=0; i<specifiedProps.length; i++) {
            	//look at each of the properties specified by user
                var property = specifiedProps[i];

                /*if this property is not specified by the user for this
                instance, sample from category means*/
                if (tokenProperties[property] == null) {
	                var type = property.slice(0,property.length-1);
	                switch(type) {
						//if target probability is specified, sample using that probability
	                	case "tar":
	                		tokenProperties[property] = this.propsAndParams[property] > Math.random();
	                		break;
	                	//sample around color mean with color variance as radius
	                	case "col":
	                		tokenProperties[property] = Ecosystem.myColor(
	                			this.propsAndParams[property]["mean"],
	                			this.propsAndParams[property]["var"]
	                		);
	                		break;
	                	//sample around proportion mean with proportion variance as radius
	                	case "prop":
	                		tokenProperties[property] = Ecosystem.uniformAroundMean(
	                			this.propsAndParams[property]["mean"],
	                			this.propsAndParams[property]["var"]
	                		);
	                		break;
	                	default:
	                        console.log(
	                        	"error 109: property parameters input to genus should be 'tar' for 'target', 'col' for 'color', or 'prop' for 'proportion'. you gave me this: " +
	                        	property + ", which i shortened to " + type +
	                        	"."
	                        );
	                }
	            }
	        }
            //pass along all user-specified
            return Ecosystem.draw(this.category, tokenProperties, paperlabel, scaleFactor);
        }

        this.oldDraw = function(paperlabel, tar1, tar2, scaleFactor) {
            this.draw(paperlabel, {"tar1":tar1, "tar2":tar2}, scaleFactor);
        }
    },

    //BACKWARDS COMPATIBILITY
    Bug: function(props) {
    	this.propsAndParams = {};
    	var meanVars = [
    		["bodyColor", "bodyColorVar", "col3"],
    		["wingsColor", "wingsColorVar", "col5"],
    		["antennaeColor", "antennaeColorVar", "col4"],
    		["headFatness", "headFatnessVar", "prop1"],
    		["bodyFatness", "bodyFatnessVar", "prop2"]
    	];
    	this.backwardsCompatibility( meanVars, props);
    	this.category = "bug";
    	this.update();
    },
    Bird: function(props) {
    	this.propsAndParams = {};
    	var meanVars = [
    		["color", "colorVar", "col1"],
    		["crestColor", "crestColorVar", "col2"],
    		["tailColor", "tailColorVar", "col3"],
    		["headStretch", "headStretchVar", "prop1"],
    		["bodyStretch", "bodyStretchVar", "prop2"]
    	];
    	this.backwardsCompatibility( meanVars, props);
    	this.category = "bird";
    	this.update();
    },
    Fish: function(props) {
    	this.propsAndParams = {};
    	var meanVars = [
    		["color", "colorVar", "col1"],
    		["finColor", "finColorVar", "col2"],
    		["tallness", "tallnessVar", "prop1"],
    		["tailSize", "tailSizeVar", "prop2"]
    	];
    	this.backwardsCompatibility( meanVars, props);
    	this.category = "fish";
    	this.update();
    },
    Flower: function(props) {
    	this.propsAndParams = {};
    	var meanVars = [
    		["petalColor", "petalColorVar", "col1"],
    		["centerColor", "centerColorVar", "col2"],
    		["spotsColor", "spotsColorVar", "col3"],
    		["stemColor", "stemColorVar", "col4"],
    		["petalLenth", "petalLenthVar", "prop1"],
    		["centerSize", "centerSizeVar", "prop2"]
    	];
    	this.backwardsCompatibility( meanVars, props);
    	this.category = "flower";
    	this.update();
    }
}

Ecosystem.Bug.prototype = new Ecosystem.Genus();
Ecosystem.Bug.prototype.constructor = Ecosystem.Bug;

Ecosystem.Bird.prototype = new Ecosystem.Genus();
Ecosystem.Bird.prototype.constructor = Ecosystem.Bird;

Ecosystem.Fish.prototype = new Ecosystem.Genus();
Ecosystem.Fish.prototype.constructor = Ecosystem.Fish;

Ecosystem.Flower.prototype = new Ecosystem.Genus();
Ecosystem.Flower.prototype.constructor = Ecosystem.Flower;


Ecosystem.Tree.prototype = new Ecosystem.Genus();
Ecosystem.Tree.prototype.constructor = Ecosystem.Tree;